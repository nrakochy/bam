<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1476736483656">{:repl-history {:ide [], :local [&quot;(def test1 {:a 1 :b 2})&quot; &quot;(filterv #(= :ref (:type test1)))&quot; &quot;(filterv #(= :ref (:type %)) test1)&quot; &quot;(def test2 [{:type \&quot;nothing\&quot; :a 1} {:type :ref :b 2}])&quot; &quot;(filterv #(= :ref (:type %)) test2)&quot; &quot; (:b (filterv #(= :ref (:type %)) test2) )&quot; &quot;(extract-references test3)&quot; &quot;(def test3 [{:type \&quot;nothing\&quot; :name \&quot;Superior\&quot;} {:type :ref :name \&quot;Check\&quot;}])&quot; &quot;(get-reference-types test3)&quot; &quot;(get-reference-types (:user data-entities))&quot; &quot;(get-reference-types [ (:user data-entities) ])&quot; &quot;(get-reference-types [ (:user data-schema) ])&quot; &quot;(get-reference-types (:user data-schema))&quot; &quot;data-entities&quot; &quot;(extract-references)&quot; &quot;(extract-references data-entities)&quot; &quot;(use '[bam.db.schema :as sch] :reload-all)&quot; &quot;(use '[bam.db.datomic-adapter :as adapter] :reload-all)&quot; &quot;()&quot; &quot;(source d/q)&quot; &quot;(user-query)&quot; &quot;(user-query db-inst 86)&quot; &quot;(:user data-schema)&quot; &quot;db-schema/datomic-schema&quot; &quot;db-schema/data-schema&quot; &quot;(use '[bam.db.datomic-adapter :as db-schema] :reload-all)&quot; &quot;datomic-schema&quot; &quot;(add-user user1)&quot; &quot;(user-query db-inst 1)&quot; &quot;(doc d/q)&quot; &quot;/user&quot; &quot;(use '[datomic.api :as dt] :reload-all)&quot; &quot;(use '[datomic.api :as dat] :reload-all)&quot; &quot;(def user1 {:id 1 :username \&quot;nrako\&quot; :fullname \&quot;Nick\&quot; :email \&quot;test@example.com\&quot;})&quot; &quot;(add-user db-inst user1)&quot; &quot;(init)&quot; &quot;db-insta&quot; &quot;(user-query \&quot;nrako\&quot;)&quot; &quot;(source x)&quot; &quot;(create-schem)&quot; &quot;(add-user test1)&quot; &quot;(user-query db-inst \&quot;nrako\&quot;)&quot; &quot;(find-wrapper user-map-query db-inst)&quot; &quot;(user-map-query db-inst \&quot;nrako\&quot;)&quot; &quot;logical-or&quot; &quot;(get-req logical-or db-inst {:db/id 1})&quot; &quot;db-inst&quot; &quot;(retrieve-entity db-inst {:user/username \&quot;nrako\&quot;})&quot; &quot;(retrieve-entity  db-inst {:user/username \&quot;nrako\&quot;})&quot; &quot;( db-inst {:user/username \&quot;nrako\&quot;})&quot; &quot;(logical-or db-inst {})&quot; &quot;(logical-or db-inst {:user/username \&quot;nrako\&quot;})&quot; &quot;(use '[bam.db.core :as core] :reload-all)&quot; &quot;(ident-by-ent-key :org\n                  )&quot; &quot;(get-reference-idents (:user data-schema))&quot; &quot;(ident-by-ent-key :user)&quot; &quot;(ident-by-ent-key :org)&quot; &quot;(use '[bam.db.schema :as my_schema] :reload-all)&quot; &quot;data-references&quot; &quot;(key {:a 1})&quot; &quot;(keys {:a 1})&quot; &quot;(some (= \&quot;category\&quot; %) (:org data-references))&quot; &quot;(some #(= \&quot;category\&quot; %) (:org data-references))&quot; &quot;(some #(= \&quot;category\&quot; %) (:workScope data-references))&quot; &quot;(vec {:a 1})&quot; &quot;(into [] {:a 1})&quot; &quot;(def test1 {:id 1 :username \&quot;nrako\&quot; :authentications [\&quot;Twitter\&quot;]})&quot; &quot;(transform-into-datomic-ids test1)&quot; &quot;(use '[bam.db.datomic-adapter :as dadap] :reload-all)&quot; &quot;(test1)&quot; &quot;(ent (test1))&quot; &quot;(:user (test1))&quot; &quot;(use '[clojure.set :as set-it] :reload-all)&quot; &quot;(defn transform-it\n  \&quot;Returns map with transformed id (as :db/id) key + temp id value (as required by Datomic),\n   ref id + related value if it exists for mapping on import\&quot;\n  [{:keys [id] :as m}]\n  (let [dat-id :db/id]\n    (-&gt; (rename-keys m {:id dat-id})\n        (assoc dat-id (set-temp-id id))\n        (set-ref-data))))&quot; &quot;(def new1 (test1))&quot; &quot;(transform-it new1)&quot; &quot;test1&quot; &quot;test2&quot; &quot;(def d1 {:id 1 :username \&quot;nrako\&quot; :authentications [\&quot;Twitter\&quot;]})&quot; &quot;(transform-it d1)&quot; &quot;(use '[clojure.stacktrace] :reload-all)&quot; &quot;(e)&quot; &quot;(use '[clojure.tools.cli :as cli] :reload-all)&quot; &quot;(source parse-opts\n        )&quot; &quot;(+ 1 1)&quot; &quot;(use '[datomic.api :as dat] :reload-all )&quot; &quot;(def test-uri\&quot;datomic:free://localhost:4334/bam_dev\&quot;)\n&quot; &quot;(d/connect test-uri)&quot; &quot;(def test-uri2 \&quot;datomic:free://localhost:4334\&quot;)\n&quot; &quot;(dat/connect test-uri2)&quot; &quot;(def test-uri \&quot;datomic:free://localhost:4334/test\&quot;)\n&quot; &quot;(dat/connect test-uri)&quot; &quot;(dat/connec test-uri2)&quot; &quot;(dat/creaet-database test-uri)&quot; &quot;(dat/create-database test-uri)&quot; &quot;(use '[bam.core :as the-core] :reload-all)&quot; &quot;(add-user db-inst test1)&quot; &quot;(use '[bam.db.core :as db-core] :reload-all)&quot; &quot;(create-schema)&quot; &quot;(use '[datomic.api :as d] :reload-all)&quot; &quot;(create-schema (d/db db-conn))&quot;], :remote [&quot;(def test10 {:username \&quot;Test10\&quot; :email \&quot;test10@example.com\&quot; :fullname \&quot;tester\&quot; :role -1})&quot; &quot;(add-user test10)&quot; &quot;(db-inst)&quot; &quot;(add-user (db-inst) test10)&quot; &quot;(use '[clojure.stacktrace] :reload-all)&quot; &quot;(add-user db-conn test10)&quot; &quot;(e)&quot; &quot;data-schema&quot; &quot;get-reference-idents&quot; &quot;(keyword \&quot;user\&quot; \&quot;string\&quot;)&quot; &quot;(keyword \&quot;user\&quot; \&quot;name\n\&quot;)&quot; &quot;(vec {:a 1})&quot; &quot;(into [] {:a 1})&quot; &quot;(seq {:a 1})&quot; &quot;(seq? [1 2])&quot; &quot;(sequential? [1 2])&quot; &quot;(sequential? \&quot;string\&quot;)&quot; &quot;(last [1 2])&quot; &quot;(use '[bam.db.schema :as my_schema] :reload-all)&quot; &quot;(create-schema)&quot; &quot;(create-schema datomic-schema)&quot; &quot;(create-schema db-conn datomic-schema)&quot; &quot;(env :database-url)&quot; &quot;(-&gt;env :database-url)&quot; &quot;(use '[bam.config :as env] :reload-all)&quot; &quot;(-&gt; env :database-url)&quot; &quot;(d/delete-database (-&gt; env :database-url))&quot; &quot;(d/create-database (-&gt; env :database-url))&quot; &quot;(use '[bam.db.schema :as schema] :reload-all)&quot; &quot;data-references&quot; &quot;(use '[bam.db.datomic-adapter :as adapter] :reload-all)&quot; &quot;datomic-schema&quot; &quot;(add-user (first data-import))&quot; &quot;(add-user db-conn (first data-import))&quot; &quot;(add-user (sample-data))&quot; &quot;(add-user (db-inst) (sample-data))&quot; &quot;(add-user db-conn (sample-data))&quot; &quot;db-conn&quot; &quot;(use '[bam.db.core :as core] :reload-all)&quot; &quot;(add-user   ( db-conn )(sample-data))&quot; &quot;(create-schema db-conn)&quot; &quot;(add-user   db-conn (sample-data))&quot; &quot;(add-user   db-conn (first (sample-data) ))&quot; &quot;(add-user   db-conn (first (rest  (sample-data)) ))&quot; &quot;(retrieve-with {:user/username \&quot;nrako\&quot;})&quot; &quot;(retrieve-with {:user/email \&quot;test@example.com\&quot;})&quot; &quot;data-entities&quot; &quot;(use '[compojure.core] :reload-all)&quot; &quot;(compile-route :get \&quot;/\&quot; [] {:test 1})&quot; &quot;(defn echo-it [input] (prn input))&quot; &quot;()&quot; &quot;(compile-route :get \&quot;/\&quot; [] echo-it)&quot; &quot;(compile-route :get \&quot;/\&quot; [] #( echo-it %))&quot; &quot;(seq {:tst 1})&quot; &quot;(GET \&quot;/\&quot; [] (echo-it 1))&quot; &quot;(GET \&quot;/:id\&quot; [] (echo-it id))&quot; &quot;(GET \&quot;/:id\&quot; [] (echo-it %))&quot; &quot;(GET \&quot;/:id\&quot; [] #(echo-it %))&quot; &quot;(GET \&quot;/:test\&quot; [] #(echo-it %))&quot; &quot;(GET \&quot;/:test\&quot; [] (ok (echo-it test)) )&quot; &quot;(def endpoints [:user :organizations :projects])&quot; &quot;(use '[compojure.api.meta :as meta] :reload-all)&quot; &quot;(use '[compojure.core :as comp-core] :reload-all)&quot; &quot;(namespace :user/test)&quot; &quot;(keyword :user/test)&quot; &quot;(name :user/test)&quot; &quot;(keyword \&quot;user/:id\&quot;)&quot; &quot;(namespace (keyword \&quot;user/:id\&quot;))&quot; &quot;(name (keyword \&quot;user/:id\&quot;))&quot; &quot;(defn rest-paths [result ent]\n  (let [path (str \&quot;/\&quot; (name ent))]\n  (conj result path (str path \&quot;/:id\&quot;))\n  ))&quot; &quot;(rest-paths :user)&quot; &quot;(rest-paths [] :user)&quot; &quot;(def ents [:user :organizations :projects])&quot; &quot;(reduce rest-paths [] ents)&quot; &quot;(compile-route :get \&quot;/user\&quot; \&quot;test\&quot;)&quot; &quot;(compile-route :get \&quot;/user\&quot; [] \&quot;test\&quot;)&quot; &quot;(compile-route :get \&quot;/user\&quot; [] #(prn % ))&quot; &quot;(use '[bam.routes.services :as servicer] :reload-all)&quot; &quot;(+ 1 1)&quot; &quot;(use '[compojure.api.sweet :as sweet] :reload-all)&quot; &quot;(use '[compojure.api.meta :as meta]  :reload-all)&quot; &quot;(def r1 [\&quot;/r1/:username\&quot; [] :path-params [username :- String] \&quot;test\&quot;])&quot; &quot;(def r1 (meta/restructure :get [\&quot;/r1/:username\&quot; [] :path-params [username :- String] \&quot;test\&quot;]))&quot; &quot;(def r1 (meta/restructure :get [\&quot;/r1/:username\&quot; [] \&quot;test\&quot;]))&quot; &quot;(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n  )&quot; &quot;(def r1 (meta/restructure :ge[\&quot;(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n r1 (meta/restructure :ge(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n r1 (meta/restructure :ge(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n r1 (meta/restructure :ge(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n r1 (meta/restructure :ge(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n r1 (meta/restructure :ge(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n r1 (meta/restructure :ge(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n r1 (meta/restructure :ge(defn get-builder [&amp; args]\n  (meta/restructure :get args)\n r1 (meta/restructure :get [\&quot;/r1/:username\&quot; [] \&quot;test\&quot;])\&quot;/r1/:username\&quot; [] \&quot;test\&quot;])\&quot;/r1/:username\&quot; [] \&quot;test\&quot;])\&quot;/r1/:username\&quot; [] \&quot;test\&quot;])\&quot;/r1/:username\&quot; [] \&quot;test\&quot;])\&quot;/r1/:username\&quot; [] \&quot;test\&quot;])\&quot;/r1/:username\&quot; [] \&quot;test\&quot;])\&quot;/r1/:username\&quot; [] \&quot;test\&quot;])\&quot; [] \&quot;test\&quot;]))&quot; &quot;(def r1 \&quot;/:username\&quot; []\n                               :path-params [username :- String]\n                               :summary \&quot;Retrieve user by username\&quot; \&quot;test\&quot; )&quot; &quot;(source &amp;)&quot; &quot;(doc &amp;)&quot; &quot;(defn printer [&amp; args] (prn (class args)))&quot; &quot;(printer 1 2 3)&quot; &quot;(prn (class []))&quot; &quot;(prn (class (make-arra 1 2 3)))&quot; &quot;(prn (class (make-array 1 2 3)))&quot; &quot;(seq [1 3 4])&quot; &quot;(class (rest (seq [1 3 4]) ))&quot; &quot;(source rest)&quot; &quot;(rest [1 2 3])&quot; &quot;(class {})&quot; &quot;(not true)&quot; &quot;(not false)&quot;]}}</component>
</project>